package win32

import (
	"fmt"
	"syscall"
	"unsafe"
)

var (
	k32 = syscall.NewLazyDLL("kernel32.dll")
	u32 = syscall.NewLazyDLL("user32.dll")
	advapi32 = syscall.NewLazyDLL("Advapi32.dll")

	getProcessTokenProc = advapi32.NewProc("GetProcessToken")
	lookupPrivilegeValueWProc = advapi32.NewProc("LookupPrivilegeValueW")
	lookupPrivilegeNameWProc = advapi32.NewProc("LookupPrivilegeNameW")
	adjustTokenPrivilegesProc = advapi32.NewProc("AdjustTokenPrivileges")
	getAsyncKeyStateProc = u32.NewProc("GetAsyncKeyState")
	virtualAllocProc = k32.NewProc("VirtualAlloc")
	createThreadProc = k32.NewProc("CreateThread")
	waitForSingleObjectProc = k32.NewProc("WaitForSingleObject")
	virtualAllocExProc = k32.NewProc("VirtualAllocEx")
	virtualFreeExProc = k32.NewProc("VirtualFreeEx")
	virtualProtectProc = k32.NewProc("VirtualProtect")
	createRemoteThreadProc = k32.NewProc("CreateRemoteThread")
	getLastErrorProc = k32.NewProc("GetLastError")
	writeProcessMemoryProc = k32.NewProc("WriteProcessMemory")
	openProcessProc = k32.NewProc("OpenProcess")
	getCurrentProcessProc = k32.NewProc("GetCurrentProcess")
	isDebuggerPresentProc = k32.NewProc("IsDebuggerPresent")
	getProcAddressProc = k32.NewProc("GetProcAddress")
	closeHandleProc = k32.NewProc("CloseHandle")
	getExitCodeThreadProc = k32.NewProc("GetExitCodeThread")
	initializeProcThreadAttributeListProc = k32.NewProc("InitializeProcThreadAttributeList")
	updateProcThreadAttributeProc = k32.NewProc("UpdateProcThreadAttribute")
	createProcessAProc = k32.NewProc("CreateProcessA")
	heapAllocProc = k32.NewProc("HeapAlloc")
	getProcessHeapProc = k32.NewProc("GetProcessHeap")
)

func OpenProcess(dwDesiredAccess DWORD, bInheritHandle BOOL, dwProcessId DWORD) (HANDLE, error) {
	h, _, err := openProcessProc.Call(
		uintptr(dwDesiredAccess),
		uintptr(bInheritHandle),
		uintptr(dwProcessId),
		)

	if h == 0 {
		return uintptr(0), err
	}

	return h, nil
}

func VirtualAllocEx(handle HANDLE, lpAddress LPVOID, dwSize SIZE_T, flAllocationType, flProtect DWORD) (uintptr, error) {
	addr, _, err := virtualAllocExProc.Call(
		handle,
		lpAddress,
		dwSize,
		uintptr(flAllocationType),
		uintptr(flProtect),
		)

	if addr == 0 {
		return uintptr(0), err
	}

	return addr, nil
}

func WriteProcessMemory(handle HANDLE, lpBaseAddress LPVOID, lpBuffer LPCVOID, nSize SIZE_T, lpNumberOfBytesWritten SIZE_T) error {
	ret, _, err := writeProcessMemoryProc.Call(
		handle,
		lpBaseAddress,
		lpBuffer,
		nSize,
		lpNumberOfBytesWritten,
		)

	if ret == 0 {
		return err
	}

	return nil
}

func VirtualProtect(lpAddress LPVOID, dwSize SIZE_T, flNewProtect DWORD, lpflOldProtect *DWORD) error {
	ok, _, err := virtualProtectProc.Call(
		lpAddress, dwSize, uintptr(flNewProtect), uintptr(unsafe.Pointer(lpflOldProtect)),
		)
	if ok != uintptr(1) {
		return err
	}

	return nil
}

func CreateRemoteThread(handle HANDLE, lpThreadAttributes *SECURITY_ATTRIBUTES, dwStackSize SIZE_T, lpStartAddress LPVOID, lpParameter LPVOID, dwCreationFlags DWORD, lpThreadId LPDWORD) (uintptr, error) {
	thread, _, err := createRemoteThreadProc.Call(
		handle,
		uintptr(unsafe.Pointer(lpThreadAttributes)),
		dwStackSize,
		lpStartAddress,
		lpParameter,
		uintptr(dwCreationFlags),
		uintptr(unsafe.Pointer(&lpThreadId)),
		)

	if thread == 0 {
		return uintptr(0), err
	}

	return thread, nil
}

func Call(addr uintptr, a... uintptr) (uintptr, uintptr, error) {
	switch len(a) {
	case 0:
		return syscall.Syscall(addr, uintptr(len(a)), 0, 0, 0)
	case 1:
		return syscall.Syscall(addr, uintptr(len(a)), a[0], 0, 0)
	case 2:
		return syscall.Syscall(addr, uintptr(len(a)), a[0], a[1], 0)
	case 3:
		return syscall.Syscall(addr, uintptr(len(a)), a[0], a[1], a[2])
	case 4:
		return syscall.Syscall6(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], 0, 0)
	case 5:
		return syscall.Syscall6(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], 0)
	case 6:
		return syscall.Syscall6(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5])
	case 7:
		return syscall.Syscall9(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], 0, 0)
	case 8:
		return syscall.Syscall9(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], 0)
	case 9:
		return syscall.Syscall9(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
	case 10:
		return syscall.Syscall12(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], 0, 0)
	case 11:
		return syscall.Syscall12(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], 0)
	case 12:
		return syscall.Syscall12(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])
	case 13:
		return syscall.Syscall15(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], 0, 0)
	case 14:
		return syscall.Syscall15(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], 0)
	case 15:
		return syscall.Syscall15(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14])
	case 16:
		return syscall.Syscall18(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], 0, 0)
	case 17:
		return syscall.Syscall18(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], 0)
	case 18:
		return syscall.Syscall18(addr, uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17])
	default:
		return uintptr(0), uintptr(0), fmt.Errorf("invalid number of args for syscall")
	}
}

func CallRaw(callid uint16, argh ...uintptr) (errcode uint32)

func WaitForSingleObject(handle HANDLE, dwMilliseconds DWORD) (uintptr, error) {
	wv, _, err := waitForSingleObjectProc.Call(handle, uintptr(dwMilliseconds))
	if wv != 0 {
		return uintptr(0), err
	}

	return wv, nil
}

func GetExitCodeThread(handle HANDLE) (uint32, error) {
	var exitCode uint32
	ok, _, err := getExitCodeThreadProc.Call(handle, uintptr(unsafe.Pointer(&exitCode)))
	if ok == 0 {
		return 0, err
	}

	return exitCode, nil
}

func CloseHandle(handle HANDLE) error {
	closed, _, err := closeHandleProc.Call(handle)
	if closed == 0 {
		return err
	}

	return nil
}

func VirtualFreeEx(handle HANDLE, lpAddress LPVOID, dwSize SIZE_T, dwFreeType DWORD) error {
	ret, _, err := virtualAllocExProc.Call(handle, lpAddress, dwSize, uintptr(dwFreeType))
	if ret == 0 {
		return err
	}

	return nil
}

func InitializeProcThreadAttributeList(lpAttributeList *PROC_THREAD_ATTRIBUTE_LIST, dwAttributeCount DWORD, dwFlags DWORD, lpSize *SIZE_T) error {
	ok, _, err := initializeProcThreadAttributeListProc.Call(uintptr(unsafe.Pointer(lpAttributeList)), uintptr(dwAttributeCount), uintptr(dwFlags), uintptr(unsafe.Pointer(lpSize)))
	if ok == 0 {
		if err.Error() != "The data area passed to a system call is too small." {
			return err
		}
	}

	return nil
}

func NewProcThreadAttributeList(maxAttrCount uint32) (*PROC_THREAD_ATTRIBUTE_LIST, error) {
	var size SIZE_T
	err := InitializeProcThreadAttributeList(nil, maxAttrCount, 0, &size)
	if err != nil {
		return nil, err
	}

	al := (*PROC_THREAD_ATTRIBUTE_LIST)(unsafe.Pointer(&make([]byte, size)[0]))
	err = InitializeProcThreadAttributeList(al, maxAttrCount, 0, &size)
	if err != nil {
		return nil, err
	}
	return al, nil
}

func HeapAlloc(handle HANDLE, dwFlags DWORD, dwBytes SIZE_T) (uintptr, error) {
	ptr, _, err := heapAllocProc.Call(handle, uintptr(dwFlags), dwBytes)
	if err != nil {
		return uintptr(0), err
	}

	return ptr, nil
}

func GetProcessHeap() uintptr {
	handle, _, _ := getProcessHeapProc.Call()
	return handle
}

func UpdateProcThreadAttribute(lpAttributeList *PROC_THREAD_ATTRIBUTE_LIST, dwFlags DWORD, attribute uintptr, lpValue PVOID, cbSize SIZE_T, lpPreviousValue PVOID, lpReturnSize *SIZE_T) error {
	ok, _, err := updateProcThreadAttributeProc.Call(
		uintptr(unsafe.Pointer(lpAttributeList)),
		uintptr(dwFlags),
		uintptr(unsafe.Pointer(attribute)),
		lpValue,
		cbSize,
		lpPreviousValue,
		uintptr(unsafe.Pointer(lpReturnSize)),
		)
	if ok == 0 && err != nil {
		return err
	}

	return nil
}

func CreateProcessA(lpApplicationName LPCSTR, lpCommandLine uintptr, lpProcessAttributes *SECURITY_ATTRIBUTES, lpThreadAttributes *SECURITY_ATTRIBUTES, bInhericHandles BOOL, dwCreationFlags DWORD, lpEnvironment LPVOID, lpCurrentDirectory LPCSTR, lpStartupInfo *syscall.StartupInfo, lpProcessInformation *syscall.ProcessInformation) error {
	ok, _, err := createProcessAProc.Call(
		lpApplicationName,
		lpCommandLine,
		uintptr(unsafe.Pointer(lpProcessAttributes)),
		uintptr(unsafe.Pointer(lpThreadAttributes)),
		uintptr(bInhericHandles),
		uintptr(dwCreationFlags),
		lpEnvironment,
		lpCurrentDirectory,
		uintptr(unsafe.Pointer(lpStartupInfo)),
		uintptr(unsafe.Pointer(lpProcessInformation)),
		)
	if ok == 0 && err != nil {
		return err
	}

	return nil
}

//https://medium.com/@justen.walker/breaking-all-the-rules-using-go-to-call-windows-api-2cbfd8c79724
func StringToCharPtr(str string) *uint8 {
	chars := append([]byte(str), 0)
	return &chars[0]
}

