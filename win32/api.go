package win32

import (
	"syscall"
	"unsafe"
)

var (
	k32 = syscall.NewLazyDLL("kernel32.dll")
	u32 = syscall.NewLazyDLL("user32.dll")
	advapi32 = syscall.NewLazyDLL("Advapi32.dll")

	getProcessTokenProc = advapi32.NewProc("GetProcessToken")
	lookupPrivilegeValueWProc = advapi32.NewProc("LookupPrivilegeValueW")
	lookupPrivilegeNameWProc = advapi32.NewProc("LookupPrivilegeNameW")
	adjustTokenPrivilegesProc = advapi32.NewProc("AdjustTokenPrivileges")
	getAsyncKeyStateProc = u32.NewProc("GetAsyncKeyState")
	virtualAllocProc = k32.NewProc("VirtualAlloc")
	createThreadProc = k32.NewProc("CreateThread")
	waitForSingleObjectProc = k32.NewProc("WaitForSingleObject")
	virtualAllocExProc = k32.NewProc("VirtualAllocEx")
	virtualFreeExProc = k32.NewProc("VirtualFreeEx")
	createRemoteThreadProc = k32.NewProc("CreateRemoteThread")
	getLastErrorProc = k32.NewProc("GetLastError")
	writeProcessMemoryProc = k32.NewProc("WriteProcessMemory")
	openProcessProc = k32.NewProc("OpenProcess")
	getCurrentProcessProc = k32.NewProc("GetCurrentProcess")
	isDebuggerPresentProc = k32.NewProc("IsDebuggerPresent")
	getProcAddressProc = k32.NewProc("GetProcAddress")
	closeHandleProc = k32.NewProc("CloseHandle")
	getExitCodeThreadProc = k32.NewProc("GetExitCodeThread")
)

func OpenProcess(dwDesiredAccess DWORD, bInheritHandle BOOL, dwProcessId DWORD) (HANDLE, error) {
	h, _, err := openProcessProc.Call(
		uintptr(dwDesiredAccess),
		uintptr(bInheritHandle),
		uintptr(dwProcessId),
		)

	if h == 0 {
		return uintptr(0), err
	}

	return h, nil
}

func VirtualAllocEx(handle HANDLE, lpAddress LPVOID, dwSize SIZE_T, flAllocationType, flProtect DWORD) (uintptr, error) {
	addr, _, err := virtualAllocExProc.Call(
		handle,
		lpAddress,
		dwSize,
		uintptr(flAllocationType),
		uintptr(flProtect),
		)

	if addr == 0 {
		return uintptr(0), err
	}

	return addr, nil
}

func WriteProcessMemory(handle HANDLE, lpBaseAddress LPVOID, lpBuffer LPCVOID, nSize SIZE_T, lpNumberOfBytesWritten SIZE_T) error {
	ret, _, err := writeProcessMemoryProc.Call(
		handle,
		lpBaseAddress,
		lpBuffer,
		nSize,
		lpNumberOfBytesWritten,
		)

	if ret == 0 {
		return err
	}

	return nil
}

func CreateRemoteThread(handle HANDLE, lpThreadAttributes LPSECURITY_ATTRIBUTES, dwStackSize SIZE_T, lpStartAddress LPVOID, lpParameter LPVOID, dwCreationFlags DWORD, lpThreadId LPDWORD) (uintptr, error) {
	thread, _, err := createRemoteThreadProc.Call(
		handle,
		uintptr(unsafe.Pointer(&lpThreadAttributes)),
		dwStackSize,
		lpStartAddress,
		lpParameter,
		uintptr(dwCreationFlags),
		uintptr(unsafe.Pointer(&lpThreadId)),
		)

	if thread == 0 {
		return uintptr(0), err
	}

	return thread, nil
}


func WaitForSingleObject(handle HANDLE, dwMilliseconds DWORD) {
	//wv, _, err := waitForSingleObjectProc.Call(handle, uintptr(dwMilliseconds))
}
