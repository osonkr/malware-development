package win32

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"reflect"
	"strings"
	"syscall"
	"unsafe"
)

const (
	ERROR_SYSCALL_NOT_FOUND = "unable to find correct syscall id"
)

var (
	ntExpectedPrefix = []byte{0x4c, 0x8b, 0xd1, 0xb8}
	ntExpectedSuffix = []byte{0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01, 0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00}

	lengthOfNtSyscalls = 32

	ntdllProcPtrs = getProcPtrs(GetModuleHandle("ntdll.dll", nil))

	ntdllWeirdCalls = []string{"NtGetTickCount", "NtdllDefWindowProc_W", "NtdllDialogWndProc_W", "NtdllDefWindowProc_A", "NtdllDialogWndProc_A", "NtQuerySystemTime"}
)

// Defined in asm.s
func GetPEBAddr() uintptr

func GetPEB() *PEB {
	return (*PEB)(unsafe.Pointer(GetPEBAddr()))
}

// Search the PEB for module to get a handle back. Optionally will take an
// encoding function to avoid module strings stored in build.
func GetModuleHandle(moduleName string, encFn func(string) string) uintptr {
	peb := GetPEB()

	if moduleName == "" {
		return peb.ImageBaseAddress
	}

	init := &peb.Ldr.InMemoryOrderModuleList

	for cur := init.FLINK; cur != init; cur = cur.FLINK {
		entry := (*LDR_DATA_TABLE_ENTRY)(unsafe.Pointer(uintptr(unsafe.Pointer(cur)) - unsafe.Offsetof(LDR_DATA_TABLE_ENTRY{}.InMemoryOrderLinks)))

		dllName := entry.BaseDllName.ToString()

		if encFn != nil {
			if encFn(strings.ToLower(dllName)) == strings.ToLower(moduleName) {
				return entry.DllBase
			}
		}

		if strings.ToLower(dllName) == strings.ToLower(moduleName) {
			return entry.DllBase
		}
	}

	return uintptr(0)
}

type Proc struct {
	Addr uintptr
}

func (p *Proc) IsHooked() bool {
	return isHooked(p.Addr)
}

func (p *Proc) GetSyscallId() uint16 {
	return getSyscallId(p.Addr)
}

func GetSyscallId(procName string, encFn func(string) string) uint16 {
	proc := getNtProc(procName, encFn)
	return proc.GetSyscallId()
}

func patchApi(addr uintptr, patch []byte) error {
	ntProtectVirtualMemorySysId := GetSyscallId("NtProtectVirtualMemory", nil)

	// NtProtectVirtualMemory rounds down the memory its passed so saving a copy of the original address
	baseAddr := addr

	handle, err := syscall.GetCurrentProcess()
	if err != nil {
		return err
	}

	var oldProtect, newOldProtect DWORD

	memSize := uint64(32)

	code := CallRaw(
		ntProtectVirtualMemorySysId,
		uintptr(handle),
		uintptr(unsafe.Pointer(&addr)),
		uintptr(unsafe.Pointer(&memSize)),
		PAGE_EXECUTE_READWRITE,
		uintptr(unsafe.Pointer(&oldProtect)),
	)
	if code != 0 {
		return errors.New(fmt.Sprintf("NtProtectVirtualMemory1 error ntstatus: %x", code))
	}

	sl := &reflect.SliceHeader{
		Data: baseAddr,
		Len:  32,
		Cap:  32,
	}
	bp := *(*[]byte)(unsafe.Pointer(sl))
	copy(bp, patch)

	code = CallRaw(
		ntProtectVirtualMemorySysId,
		uintptr(handle),
		uintptr(unsafe.Pointer(&addr)),
		uintptr(unsafe.Pointer(&memSize)),
		uintptr(oldProtect),
		uintptr(unsafe.Pointer(&newOldProtect)),
	)
	if code != 0 {
		return errors.New(fmt.Sprintf("NtProtectVirtualMemory2 error ntstatus: %x", code))
	}

	return nil
}

func PatchApi(procName string, patch []byte) error {
	ntdll := GetModuleHandle("ntdll.dll", nil)
	proc := GetProc(ntdll, procName, nil)

	return patchApi(proc.Addr, patch)
}

// Best efforts here, no promise
func UnHookedAPI(procName string) error {
	ntdll := GetModuleHandle("ntdll.dll", nil)
	proc := GetProc(ntdll, procName, nil)
	procSysId := proc.GetSyscallId()

	if procSysId == 0 {
		return errors.New("unable to find correct syscall id" + procName)
	}

	if !proc.IsHooked() {
		return nil
	}

	patch := unhookApiPatch(procSysId)

	return patchApi(proc.Addr, patch)
}

func unhookApiPatch(sysid uint16) []byte {
	patch := append(ntExpectedPrefix, []byte{byte(sysid), 0x00, 0x00, 0x00}[:]...)
	patch = append(patch, ntExpectedSuffix[:]...)
	return patch
}

func ntdllHookExcluded(name string) bool {
	for _, n := range ntdllWeirdCalls {
		if n == name {
			return true
		}
	}

	return false
}

func GetListOfHookedApiCalls() []string {
	var s []string
	for n, p := range ntdllProcPtrs {
		if p.IsHooked() && !ntdllHookExcluded(n) {
			s = append(s, n)
		}
	}

	return s
}

func getProcPtrs(handle HANDLE) map[string]*Proc {
	procPtrs := map[string]*Proc{}

	dosHdr := (*IMAGE_DOS_HEADER)(unsafe.Pointer(handle))
	ntHdr := (*IMAGE_NT_HEADER)(unsafe.Pointer(handle + uintptr(dosHdr.FileAddrNewEXEHeader)))

	optHdr := &ntHdr.OptionalHeader

	exportDataDir := optHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
	exportDirAddr := (*IMAGE_EXPORT_DIRECTORY)(unsafe.Pointer(handle + uintptr(exportDataDir.VirtualAddress)))

	numOfNames := int(exportDirAddr.NumberOfNames)

	funcs := (*DWORD)(unsafe.Pointer(handle + uintptr(exportDirAddr.AddressOfFunctions)))
	names := (*DWORD)(unsafe.Pointer(handle + uintptr(exportDirAddr.AddressOfNames)))
	ords := (*WORD)(unsafe.Pointer(handle + uintptr(exportDirAddr.AddressOfNameOrdinals)))

	for i := 0; i < numOfNames; i++ {
		nameOffset := (*DWORD)(unsafe.Pointer(uintptr(unsafe.Pointer(names)) + uintptr(i*4)))

		// I dunno, C strings suck
		nameBuffP := (*[128]byte)(unsafe.Pointer(handle + uintptr(*nameOffset)))

		// find length of c string by searching for next null byte
		var l int
		for j, b := range *nameBuffP {
			l = j
			if b == 0x00 {
				break
			}
		}

		name := string((*nameBuffP)[:l])

		if strings.HasPrefix(name, "Nt") {
			ordFuncPtrOffset := (*WORD)(unsafe.Pointer(uintptr(unsafe.Pointer(ords)) + uintptr(i+int(exportDirAddr.Base))*2))
			funcPtrOffset := (*DWORD)(unsafe.Pointer(uintptr(unsafe.Pointer(funcs)) + uintptr((*ordFuncPtrOffset-WORD(exportDirAddr.Base))*4)))
			funcPtr := handle + uintptr(*funcPtrOffset)

			procPtrs[name] = &Proc{Addr: funcPtr}
		}
	}

	return procPtrs
}

func GetProc(handle uintptr, procName string, encFn func(string) string) *Proc {
	if strings.HasPrefix(procName, "Nt") {
		return getNtProc(procName, encFn)
	}

	procs := getProcPtrs(handle)

	if encFn == nil {
		return procs[procName]
	}

	for name, proc := range procs {
		if !(encFn(name) == procName) {
			continue
		}

		return proc
	}


	return nil
}

func getNtProc(procName string, encFn func(string) string) *Proc {
	if encFn == nil {
		return ntdllProcPtrs[procName]
	}

	for name, proc := range ntdllProcPtrs {
		if !(encFn(name) == procName) {
			continue
		}

		return proc
	}


	return nil
}

// Will request the environment variables from the PEB of the current process
func GetEnvironmentVariables() []byte {
	peb := GetPEB()

	envP := peb.ProcessParameters.Environment
	envS := int(peb.ProcessParameters.EnvironmentSize)
	buf := rawMemToSlice(uintptr(envP), envS, envS)


	buf = bytes.Trim(buf, string(0x00))

	var envVars []byte
	for i, b := range buf {
		if b != 0x00 {
			envVars = append(envVars, b)
			continue
		}

		if buf[i - 1] == 0x00 && buf[i + 1] == 0x00 {
			envVars = append(envVars, b)
		}
	}

	return envVars
}

func getSyscallFuncPtrBytes(ptr uintptr) []byte {
	l := lengthOfNtSyscalls
	b := &reflect.SliceHeader{
		Data: ptr,
		Len:  l,
		Cap:  l,
	}

	bp := *(*[]byte)(unsafe.Pointer(b))

	buf := make([]byte, l, l)
	copy(buf, bp)

	return buf
}

func isHooked(ptr uintptr) bool {
	buf := getSyscallFuncPtrBytes(ptr)

	// Not sure how useful this actually is, ignore for now
	//return !bytes.HasPrefix(buf, ntExpectedPrefix) || !bytes.HasSuffix(buf, ntExpectedSuffix)
	return !bytes.HasPrefix(buf, ntExpectedPrefix)
}

// getSyscallId will return 0 if nothing was found
func getSyscallId(ptr uintptr) uint16 {
	buf := getSyscallFuncPtrBytes(ptr)

	if !isHooked(ptr) {
		return binary.LittleEndian.Uint16(buf[4:8])
	}

	return attemptHalosGate(ptr, 32)
}

func attemptHalosGate(ptr uintptr, maxTries int) uint16 {
	symOffset := lengthOfNtSyscalls

	for i := 1; i <= maxTries; i++ {
		up := ptr - uintptr(symOffset * i)
		if !isHooked(up) {
			return getSyscallId(up) + uint16(i)
		}

		down := ptr + uintptr(symOffset * i)
		if !isHooked(down) {
			return getSyscallId(down) - uint16(i)
		}
	}

	return 0
}
