package win32

import (
	"bytes"
	"fmt"
	"strings"
	"unsafe"
)

func GetPEBAddr() uintptr

func GetPEB() *PEB {
	return (*PEB)(unsafe.Pointer(GetPEBAddr()))
}

// Search the PEB for module to get a handle back. Optionally will take an
// encoding function to avoid module strings stored in build.
func GetModuleHandle(moduleName string, encFn func(string) string) uintptr {
	peb := GetPEB()

	if moduleName == "" {
		return peb.ImageBaseAddress
	}

	init := &peb.Ldr.InMemoryOrderModuleList

	for curr := (*LIST_ENTRY)(unsafe.Pointer(init.FLINK)); curr != init; curr = (*LIST_ENTRY)(unsafe.Pointer(curr.FLINK)) {
		if curr.FLINK == 0 {
			continue
		}

		entry := (*LDR_DATA_TABLE_ENTRY)(unsafe.Pointer(curr.FLINK))

		dllName := entry.FullDllName.ToString()

		//DEBUG
		//fmt.Printf("DllBase: %x\tName: %s\n", entry.DllBase, dllName)

		if encFn != nil {
			if encFn(strings.ToLower(dllName)) == strings.ToLower(moduleName) {
				return entry.DllBase
			}
		}

		if strings.ToLower(dllName) == strings.ToLower(moduleName) {
			return entry.DllBase
		}
	}


	return uintptr(0)
}

// Will request the environment variables from the PEB of the current process
func GetEnvironmentVariables() []byte {
	peb := GetPEB()

	fmt.Printf("%s\n", peb.ProcessParameters.ImagePathName.ToString())

	envP := peb.ProcessParameters.Environment
	envS := int(peb.ProcessParameters.EnvironmentSize)
	buf := rawMemToSlice(envP, envS, envS)


	buf = bytes.Trim(buf, string(0x00))

	var envVars []byte
	for i, b := range buf {
		if b != 0x00 {
			envVars = append(envVars, b)
			continue
		}

		if buf[i - 1] == 0x00 && buf[i + 1] == 0x00 {
			envVars = append(envVars, b)
		}
	}

	return envVars
}

func GetExportTable() {

}
