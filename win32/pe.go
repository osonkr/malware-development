package win32

import (
	"bytes"
	"fmt"
	"strings"
	"unsafe"
)

func GetPEBAddr() uintptr

func GetPEB() *PEB {
	return (*PEB)(unsafe.Pointer(GetPEBAddr()))
}

// Search the PEB for module to get a handle back. Optionally will take a
// hashing function to avoid module strings.
func GetModuleHandle(moduleName string, hashFn func(string) string) uintptr {
	peb := GetPEB()

	if moduleName == "" {
		return peb.ImageBaseAddress
	}

	init := (*LIST_ENTRY)(unsafe.Pointer(peb.Ldr.InMemoryOrderModuleList.FLINK))

	for le := init; le != &peb.Ldr.InMemoryOrderModuleList; le = (*LIST_ENTRY)(unsafe.Pointer(le.FLINK)) {
		if le.FLINK == 0 {
			break
		}

		entry := (*LDR_DATA_TABLE_ENTRY)(unsafe.Pointer(le.FLINK))

		dllName := entry.FullDllName.ToString()

		if hashFn != nil {
			if hashFn(strings.ToLower(dllName)) == strings.ToLower(moduleName) {
				return entry.DllBase
			}
		}

		if strings.ToLower(dllName) == strings.ToLower(moduleName) {
			return entry.DllBase
		}
	}


	return uintptr(0)
}

// Will request the environment variables from the PEB of the current process
func GetEnvironmentVariables() []byte {
	peb := GetPEB()

	fmt.Printf("%s\n", peb.ProcessParameters.ImagePathName.ToString())

	envP := peb.ProcessParameters.Environment
	envS := int(peb.ProcessParameters.EnvironmentSize)
	buf := rawMemToSlice(envP, envS, envS)


	buf = bytes.Trim(buf, string(0x00))

	var envVars []byte
	for i, b := range buf {
		if b != 0x00 {
			envVars = append(envVars, b)
			continue
		}

		if buf[i - 1] == 0x00 && buf[i + 1] == 0x00 {
			envVars = append(envVars, b)
		}
	}

	return envVars
}

func GetExportTable() {

}
